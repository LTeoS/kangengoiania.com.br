/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import state from '../../store'
import { useSnapshot } from 'valtio'
import { LoopOnce } from 'three'

type GLTFResult = GLTF & {
  nodes: {
    body_1: THREE.Mesh
    body_2: THREE.Mesh
    body_3: THREE.Mesh
    bottom_drawer_1: THREE.Mesh
    bottom_drawer_2: THREE.Mesh
    top_drawer: THREE.Mesh
    Circle014: THREE.Mesh
    Circle014_1: THREE.Mesh
    cleaning_bottle: THREE.Mesh
    filter_1: THREE.Mesh
    filter_2: THREE.Mesh
    plate: THREE.Mesh
    plate_1: THREE.Mesh
    lock: THREE.Mesh
    tray_1: THREE.Mesh
    tray_2: THREE.Mesh
    plate002: THREE.Mesh
    plate002_1: THREE.Mesh
    plate003: THREE.Mesh
    plate003_1: THREE.Mesh
    plate004: THREE.Mesh
    plate004_1: THREE.Mesh
    plate005: THREE.Mesh
    plate005_1: THREE.Mesh
    plate006: THREE.Mesh
    plate006_1: THREE.Mesh
    plate007: THREE.Mesh
    plate007_1: THREE.Mesh
    plate008: THREE.Mesh
    plate008_1: THREE.Mesh
  }
  materials: {
    Milk: THREE.MeshStandardMaterial
    ['Piano Finish']: THREE.MeshStandardMaterial
    ['Material.007']: THREE.MeshStandardMaterial
    ['Glass Simple']: THREE.MeshBasicMaterial
    ['Material.006']: THREE.MeshStandardMaterial
    ['Wax Plastic']: THREE.MeshStandardMaterial
    ['Elastic Rubber']: THREE.MeshPhysicalMaterial
    ['Old White Metal']: THREE.MeshStandardMaterial
  }
}

export default function Model() {
  const group = useRef<THREE.Group>(null)
  const { scene, animations } = useGLTF(
    '/objects/animated.glb',
    'https://www.gstatic.com/draco/v1/decoders/draco_decoder.js',
  ) as GLTFResult
  const { actions } = useAnimations(animations, group)
  const snap = useSnapshot(state)

  useEffect(() => {
    if (snap.filterAction) {
      actions.enhancerActionEnd!.stop()
      actions.displayActionEnd!.stop()
      actions.filterActionEnd!.stop()
      actions.plateActionEnd!.stop()
      actions.filterActionIntro!.reset().play()
      actions.filterActionIntro!.clampWhenFinished = true
      actions.filterActionIntro!.setLoop(LoopOnce, 1)
      return () => {
        actions.filterActionIntro!.stop()
        actions.filterActionEnd!.reset().play()
        actions.filterActionEnd!.clampWhenFinished = true
        actions.filterActionEnd!.setLoop(LoopOnce, 1)
      }
    }
  }, [snap.filterAction])

  useEffect(() => {
    if (snap.displayAction) {
      actions.enhancerActionEnd!.stop()
      actions.displayActionEnd!.stop()
      actions.filterActionEnd!.stop()
      actions.plateActionEnd!.stop()
      actions.displayActionIntro!.reset().play()
      actions.displayActionIntro!.clampWhenFinished = true
      actions.displayActionIntro!.setLoop(LoopOnce, 1)
      return () => {
        actions.displayActionIntro!.stop()
        actions.displayActionEnd!.reset().play()
        actions.displayActionEnd!.clampWhenFinished = true
        actions.displayActionEnd!.setLoop(LoopOnce, 1)
      }
    }
  }, [snap.displayAction])

  useEffect(() => {
    if (snap.enhancerAction) {
      actions.enhancerActionEnd!.stop()
      actions.displayActionEnd!.stop()
      actions.filterActionEnd!.stop()
      actions.plateActionEnd!.stop()
      actions.enhancerActionIntro!.reset().play()
      actions.enhancerActionIntro!.clampWhenFinished = true
      actions.enhancerActionIntro!.setLoop(LoopOnce, 1)
      return () => {
        actions.enhancerActionIntro!.stop()
        actions.enhancerActionEnd!.reset().play()
        actions.enhancerActionEnd!.clampWhenFinished = true
        actions.enhancerActionEnd!.setLoop(LoopOnce, 1)
      }
    }
  }, [snap.enhancerAction])

  useEffect(() => {
    if (snap.plateAction) {
      actions.enhancerActionEnd!.stop()
      actions.displayActionEnd!.stop()
      actions.filterActionEnd!.stop()
      actions.plateActionEnd!.stop()
      actions.plateActionIntro!.reset().play()
      actions.plateActionIntro!.clampWhenFinished = true
      actions.plateActionIntro!.setLoop(LoopOnce, 1)
      return () => {
        actions.plateActionIntro!.stop()
        actions.plateActionEnd!.reset().play()
        actions.plateActionEnd!.clampWhenFinished = true
        actions.plateActionEnd!.setLoop(LoopOnce, 1)
      }
    }
  }, [snap.plateAction])

  return <primitive object={scene} ref={group} dispose={null} />
}

useGLTF.preload('/objects/animated.glb')
